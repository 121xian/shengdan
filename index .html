<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rock Solid Photo Display - Enhanced Version</title>
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at center, #05101a 0%, #000000 100%);
            font-family: 'Arial', sans-serif; 
        }
        
        #top-header {
            position: absolute; top: 15px; left: 0; width: 100%;
            text-align: center; z-index: 50; pointer-events: none;
        }
        #top-header h1 {
            font-family: 'Brush Script MT', cursive; font-size: 55px; margin: 0;
            background: linear-gradient(to bottom, #fff, #ffd700);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.6));
            animation: floatText 4s ease-in-out infinite;
        }
        @keyframes floatText { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-8px);} }

        #ui-container {
            position: absolute; top: 120px; left: 20px; width: 300px;
            padding: 20px; 
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff; z-index: 100; display: flex; flex-direction: column; gap: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            transition: opacity 0.3s ease;
        }
        #ui-container.hidden {
            opacity: 0.2;
        }
        #ui-container.hidden:hover {
            opacity: 1;
        }

        #control-bar {
            position: absolute; bottom: 20px; left: 0; width: 100%;
            display: flex; justify-content: center; gap: 10px; z-index: 99;
        }
        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255,215,0,0.3);
            color: #ffeb3b; padding: 8px 15px; border-radius: 8px;
            cursor: pointer; font-size: 12px; transition: 0.3s;
            backdrop-filter: blur(5px);
        }
        .control-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.05);
        }

        #video-wrapper {
            width: 100%; height: 160px; border-radius: 10px; overflow: hidden;
            background: #000; position: relative; transform: scaleX(-1);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        .status-badge {
            position: absolute; top: 8px; right: 8px;
            background: #ffeb3b; color: #000;
            padding: 3px 8px; border-radius: 4px; font-size: 11px;
            transform: scaleX(-1); font-weight: 800; display: none;
        }

        .file-upload {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255,215,0,0.3);
            padding: 10px; border-radius: 8px; color: #ffeb3b; cursor: pointer;
            text-align: center; font-size: 13px; transition: 0.3s; font-weight: bold;
        }
        .file-upload:hover { background: rgba(255, 215, 0, 0.2); }
        input[type="file"] { display: none; }

        #gesture-info {
            font-size: 11px; color: #bbb; line-height: 1.6;
            background: rgba(0,0,0,0.4); padding: 12px; border-radius: 8px;
        }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            color: #ffeb3b; z-index: 999; flex-direction: column;
        }

        .tree-type-selector {
            display: flex; gap: 8px; margin-top: 5px;
        }
        .tree-type-btn {
            flex: 1; padding: 6px; background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,215,0,0.2); border-radius: 5px;
            color: #ffd700; cursor: pointer; font-size: 11px; text-align: center;
        }
        .tree-type-btn.active {
            background: rgba(255,215,0,0.2);
            font-weight: bold;
        }

        #music-player {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 10px;
            display: none; z-index: 90; color: white; font-size: 12px;
            backdrop-filter: blur(5px);
        }
        #music-controls {
            display: flex; align-items: center; gap: 10px;
        }
        #music-controls button {
            background: none; border: none; color: #ffd700; cursor: pointer;
            font-size: 16px;
        }
        #volume-slider {
            width: 60px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="top-header"><h1>Merry Christmas</h1></div>

    <div id="loader">
        <h2>â„ï¸ ç”»é¢é˜²æŠ–ç³»ç»Ÿå¯åŠ¨...</h2>
        <p>åˆå§‹åŒ–ä¸­</p>
    </div>

    <div id="ui-container">
        <div id="video-wrapper">
            <video id="input_video"></video>
            <div id="status-text" class="status-badge">Ready</div>
        </div>
        
        <label class="file-upload" for="photo-input">ğŸ“· å¯¼å…¥ç…§ç‰‡ (è‡ªåŠ¨ä¿å­˜)</label>
        <input type="file" id="photo-input" accept="image/*" multiple>
        
        <label class="file-upload" for="video-input">ğŸ¬ å¯¼å…¥è§†é¢‘</label>
        <input type="file" id="video-input" accept="video/*">
        
        <label class="file-upload" for="music-input">ğŸµ å¯¼å…¥éŸ³ä¹</label>
        <input type="file" id="music-input" accept="audio/*">
        
        <div style="margin-top: 10px;">
            <div style="font-size: 12px; color: #ffd700; margin-bottom: 5px;">ğŸ„ åœ£è¯æ ‘ç±»å‹:</div>
            <div class="tree-type-selector">
                <div class="tree-type-btn active" data-type="classic">ç»å…¸æ¾æ ‘</div>
                <div class="tree-type-btn" data-type="spiral">èºæ—‹æ ‘</div>
                <div class="tree-type-btn" data-type="crystal">æ°´æ™¶æ ‘</div>
                <div class="tree-type-btn" data-type="fractal">åˆ†å½¢æ ‘</div>
            </div>
        </div>
        
        <div id="gesture-info">
            âœ‹ <b>å¼ å¼€</b>ï¼šç…§ç‰‡æ˜Ÿç³»çˆ†å‘<br>
            âœŠ <b>æ¡æ‹³</b>ï¼šåˆ‡æ¢åœ£è¯æ ‘<br>
            â˜ï¸ <b>å•æŒ‡</b>ï¼šå•å¼ ç‰¹å†™ (ç»å¯¹é™æ­¢)<br>
            ğŸ‘Œ <b>OKæ‰‹</b>ï¼šå·¨å‹è‰ºæœ¯å­—<br>
            âœŒï¸ <b>Vå­—</b>ï¼šæ’­æ”¾è§†é¢‘ (æ–°)<br>
            ğŸ¤˜ <b>æ‘‡æ»šæ‰‹</b>ï¼šéŸ³ä¹æ§åˆ¶ (æ–°)
        </div>
    </div>

  
<div id="control-bar">
    <button class="control-btn" onclick="toggleFullscreen()">â›¶ å…¨å±</button>
    <button class="control-btn" onclick="toggleUI()">ğŸ‘ï¸ éšè—UI</button>
    <button class="control-btn" onclick="shareToWeChat()">ğŸ’¬ åˆ†äº«åˆ°å¾®ä¿¡</button>
    <button class="control-btn" onclick="clearStorage()">ğŸ—‘ï¸ æ¸…é™¤æ•°æ®</button>
    <button class="control-btn" onclick="exportSettings()">ğŸ’¾ å¯¼å‡ºé…ç½®</button>
</div>
    <div id="music-player">
        <div id="music-controls">
            <button onclick="toggleMusic()">â¯ï¸</button>
            <button onclick="prevTrack()">â®ï¸</button>
            <button onclick="nextTrack()">â­ï¸</button>
            <span id="current-track">æ— éŸ³ä¹</span>
            <input type="range" id="volume-slider" min="0" max="100" value="50">
        </div>
    </div>

    <script>
        // --- 1. æ•°æ®å­˜å‚¨ç®¡ç† ---
        class DataManager {
            static STORAGE_KEY = 'photoGalleryData';
            
            static saveData(data) {
                try {
                    // å‹ç¼©æ•°æ®ï¼šåªä¿å­˜base64å­—ç¬¦ä¸²å’Œå¿…è¦çš„å…ƒæ•°æ®
                    const compressed = {
                        photos: data.photos.map(photo => ({
                            data: photo.data,
                            name: photo.name,
                            size: photo.size
                        })),
                        settings: data.settings,
                        treeType: data.treeType,
                        lastUpdated: Date.now()
                    };
                    
                    // æ£€æŸ¥å­˜å‚¨å¤§å°ï¼ˆé™åˆ¶ä¸º5MBï¼‰
                    const jsonStr = JSON.stringify(compressed);
                    if (jsonStr.length > 5 * 1024 * 1024) {
                        alert('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œå°†åˆ é™¤æœ€æ—§çš„ç…§ç‰‡');
                        compressed.photos = compressed.photos.slice(-10); // åªä¿ç•™æœ€è¿‘10å¼ 
                    }
                    
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(compressed));
                    console.log('æ•°æ®å·²ä¿å­˜');
                } catch (e) {
                    console.error('ä¿å­˜æ•°æ®å¤±è´¥:', e);
                }
            }
            
            static loadData() {
                try {
                    const saved = localStorage.getItem(this.STORAGE_KEY);
                    if (saved) {
                        return JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('åŠ è½½æ•°æ®å¤±è´¥:', e);
                }
                return null;
            }
            
            static clearData() {
                localStorage.removeItem(this.STORAGE_KEY);
                location.reload();
            }
            
            static exportSettings() {
                const data = this.loadData();
                if (data) {
                    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `photo-gallery-backup-${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }
        }

        // --- 2. éŸ³ä¹æ’­æ”¾å™¨ ---
        class MusicPlayer {
            constructor() {
                this.audio = new Audio();
                this.playlist = [];
                this.currentIndex = -1;
                this.isPlaying = false;
                this.volume = 0.5;
                
                this.audio.volume = this.volume;
                this.audio.addEventListener('ended', () => this.nextTrack());
                
                // éŸ³é‡æ§åˆ¶
                document.getElementById('volume-slider').addEventListener('input', (e) => {
                    this.setVolume(e.target.value / 100);
                });
            }
            
            addTrack(file) {
                const url = URL.createObjectURL(file);
                this.playlist.push({
                    name: file.name,
                    url: url,
                    file: file
                });
                
                if (this.currentIndex === -1) {
                    this.currentIndex = 0;
                    this.playCurrent();
                }
                
                document.getElementById('music-player').style.display = 'block';
                this.updateTrackInfo();
            }
            
            playCurrent() {
                if (this.playlist.length > 0 && this.currentIndex >= 0) {
                    this.audio.src = this.playlist[this.currentIndex].url;
                    this.audio.play().catch(e => console.log('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢:', e));
                    this.isPlaying = true;
                    this.updateTrackInfo();
                }
            }
            
            togglePlay() {
                if (this.isPlaying) {
                    this.audio.pause();
                } else {
                    this.audio.play().catch(e => console.log('æ’­æ”¾å¤±è´¥:', e));
                }
                this.isPlaying = !this.isPlaying;
            }
            
            nextTrack() {
                if (this.playlist.length > 0) {
                    this.currentIndex = (this.currentIndex + 1) % this.playlist.length;
                    this.playCurrent();
                }
            }
            
            prevTrack() {
                if (this.playlist.length > 0) {
                    this.currentIndex = (this.currentIndex - 1 + this.playlist.length) % this.playlist.length;
                    this.playCurrent();
                }
            }
            
            setVolume(vol) {
                this.volume = vol;
                this.audio.volume = vol;
            }
            
            updateTrackInfo() {
                if (this.playlist.length > 0 && this.currentIndex >= 0) {
                    document.getElementById('current-track').textContent = 
                        this.playlist[this.currentIndex].name;
                }
            }
            
            getAnalyser() {
                // è¿”å›éŸ³é¢‘åˆ†æå™¨ç”¨äºå¯è§†åŒ–
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaElementSource(this.audio);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                return analyser;
            }
        }

        // --- 3. åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x05101a, 0.0015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 85;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // åˆå§‹åŒ–éŸ³ä¹æ’­æ”¾å™¨
        const musicPlayer = new MusicPlayer();

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const mainLight = new THREE.PointLight(0xffd700, 3, 150);
        mainLight.position.set(30, 40, 50);
        scene.add(mainLight);
        const blueLight = new THREE.PointLight(0x00aaff, 2, 100);
        blueLight.position.set(-30, -10, 30);
        scene.add(blueLight);

        // --- 4. é›ªèŠ± ---
        function createSnowflakeTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            context.fillStyle = gradient;
            context.beginPath(); context.arc(32, 32, 30, 0, Math.PI * 2); context.fill();
            return new THREE.CanvasTexture(canvas);
        }
        const snowCount = 800;
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = new Float32Array(snowCount * 3);
        for(let i=0;i<snowCount*3;i++) snowPos[i] = (Math.random()-0.5)*250;
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({
            color: 0xffffff, size: 5.5, transparent: true, opacity: 0.9,
            map: createSnowflakeTexture(), blending: THREE.AdditiveBlending, depthWrite: false
        });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);

        // --- 5. ç²’å­ç³»ç»Ÿ ---
        const totalParticles = 2400;
        const countCubes = 1100; const countSpheres = 600; const countFrames = 300; const countGifts = 400;

        const cubeGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const sphereGeo = new THREE.SphereGeometry(0.6, 16, 16);
        const frameGeo = new THREE.TorusGeometry(1.4, 0.25, 4, 4); frameGeo.rotateZ(Math.PI/4);
        const giftGeo = new THREE.BoxGeometry(1.0, 1.0, 1.0);

        const matYellow = new THREE.MeshStandardMaterial({ color: 0xffeb3b, emissive: 0xaa8800, roughness: 0.2 });
        const matColor = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
        const matFrame = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x666666, metalness: 0.9 });
        
        const gCan = document.createElement('canvas'); gCan.width=64; gCan.height=64;
        const gCtx = gCan.getContext('2d');
        gCtx.fillStyle='#c62828'; gCtx.fillRect(0,0,64,64);
        gCtx.fillStyle='#ffd700'; gCtx.fillRect(28,0,8,64); gCtx.fillRect(0,28,64,8);
        const matGift = new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(gCan) });

        const meshCubes = new THREE.InstancedMesh(cubeGeo, matYellow, countCubes);
        const meshSpheres = new THREE.InstancedMesh(sphereGeo, matColor, countSpheres);
        const meshFrames = new THREE.InstancedMesh(frameGeo, matFrame, countFrames);
        const meshGifts = new THREE.InstancedMesh(giftGeo, matGift, countGifts);

        scene.add(meshCubes); scene.add(meshSpheres); scene.add(meshFrames); scene.add(meshGifts);

        const targetPositions = new Float32Array(totalParticles * 3);
        const currentPositions = new Float32Array(totalParticles * 3);
        const dummy = new THREE.Object3D();
        const colorRed = new THREE.Color(0xdc143c);
        const colorGreen = new THREE.Color(0x228b22);
        let sIdx = 0;

        for(let i=0; i<totalParticles; i++) {
            currentPositions[i*3] = (Math.random()-0.5)*150;
            currentPositions[i*3+1] = (Math.random()-0.5)*150;
            currentPositions[i*3+2] = (Math.random()-0.5)*150;
            if(i>=countCubes && i<countCubes+countSpheres) meshSpheres.setColorAt(sIdx++, (Math.random()>0.5)?colorRed:colorGreen);
        }

        // --- 6. å¤šç±»å‹åœ£è¯æ ‘ ---
        const treeGenerators = {
            classic: function(scale) { // ç»å…¸æ¾æ ‘
                for(let i=0; i<totalParticles; i++){
                    let hPct = Math.random(); 
                    const y = (24 - (hPct * 50)) * scale; 
                    const maxR = hPct * 22 * scale;
                    const r = maxR * Math.sqrt(Math.random());
                    const th = Math.random()*2*Math.PI;
                    targetPositions[i*3] = r*Math.cos(th);
                    targetPositions[i*3+1] = y;
                    targetPositions[i*3+2] = r*Math.sin(th);
                }
            },
            spiral: function(scale) { // èºæ—‹æ ‘
                for(let i=0; i<totalParticles; i++){
                    const t = Math.random();
                    const turns = 5;
                    const angle = t * Math.PI * 2 * turns;
                    const y = (t - 0.5) * 50 * scale;
                    const r = (1 - t) * 20 * scale;
                    targetPositions[i*3] = Math.cos(angle) * r;
                    targetPositions[i*3+1] = y;
                    targetPositions[i*3+2] = Math.sin(angle) * r;
                }
            },
            crystal: function(scale) { // æ°´æ™¶æ ‘
                for(let i=0; i<totalParticles; i++){
                    const layers = 8;
                    const layer = Math.floor(Math.random() * layers);
                    const layerHeight = (layer / layers) * 40 * scale;
                    const y = -20 + layerHeight + (Math.random() - 0.5) * 4;
                    
                    const angleCount = 6; // å…­è¾¹å½¢
                    const angle = Math.floor(Math.random() * angleCount) * (Math.PI * 2 / angleCount);
                    const r = (1 - layer/layers) * 15 * scale + Math.random() * 3;
                    
                    targetPositions[i*3] = Math.cos(angle) * r;
                    targetPositions[i*3+1] = y;
                    targetPositions[i*3+2] = Math.sin(angle) * r;
                }
            },
            fractal: function(scale) { // åˆ†å½¢æ ‘
                function generateBranch(x, y, z, angle, length, depth, idx, startIdx) {
                    if(depth >= 4 || idx >= totalParticles) return idx;
                    
                    const endX = x + Math.cos(angle) * length;
                    const endY = y + length * 0.7;
                    const endZ = z + Math.sin(angle) * length;
                    
                    // ç”Ÿæˆåˆ†æ”¯ç²’å­
                    const points = 8;
                    for(let i=0; i<points && idx < totalParticles; i++) {
                        const t = i / points;
                        targetPositions[idx*3] = x + (endX - x) * t;
                        targetPositions[idx*3+1] = y + (endY - y) * t;
                        targetPositions[idx*3+2] = z + (endZ - z) * t;
                        idx++;
                    }
                    
                    if(depth < 3) {
                        const branches = 2 + Math.floor(Math.random() * 2);
                        for(let b=0; b<branches; b++) {
                            const newAngle = angle + (Math.random() - 0.5) * 1.5;
                            const newLength = length * (0.6 + Math.random() * 0.2);
                            idx = generateBranch(endX, endY, endZ, newAngle, newLength, depth+1, idx, startIdx);
                        }
                    }
                    return idx;
                }
                
                let idx = 0;
                idx = generateBranch(0, -20, 0, Math.PI/2, 25, 0, idx, 0);
                
                // å¡«å……å‰©ä½™ç²’å­
                while(idx < totalParticles) {
                    targetPositions[idx*3] = (Math.random()-0.5)*30;
                    targetPositions[idx*3+1] = -20 + Math.random()*40;
                    targetPositions[idx*3+2] = (Math.random()-0.5)*30;
                    idx++;
                }
            }
        };

        // --- 7. æ ‘é¡¶è£…é¥° ---
        const shape = new THREE.Shape();
        const pts = 5; const outR = 3.5; const inR = 1.5;
        for(let i=0; i<pts*2; i++){
            const r = (i%2===0)?outR:inR; const a = (i/(pts*2))*Math.PI*2;
            const x=Math.cos(a+Math.PI/2)*r; const y=Math.sin(a+Math.PI/2)*r;
            if(i===0) shape.moveTo(x,y); else shape.lineTo(x,y);
        }
        shape.closePath();
        const starGeo = new THREE.ExtrudeGeometry(shape, { depth: 0.8, bevelEnabled:true, bevelThickness:0.3, bevelSize:0.2, bevelSegments:3 });
        const starMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 1.2 });
        const topStar = new THREE.Mesh(starGeo, starMat);
        scene.add(topStar);

        // èºæ—‹å…‰å¸¦
        class Spiral extends THREE.Curve {
            getPoint(t) {
                const turns = 4.5; const angle = t*Math.PI*2*turns;
                const h = (t-0.5)*50; 
                const r = (1-t)*22 + 2; 
                return new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r);
            }
        }
        const tubeMesh = new THREE.Mesh(new THREE.TubeGeometry(new Spiral(), 120, 0.4, 8, false), 
            new THREE.MeshBasicMaterial({color:0xffd700, transparent:true, opacity:0.6, blending:THREE.AdditiveBlending}));
        tubeMesh.visible = false;
        scene.add(tubeMesh);

        // --- 8. è§†é¢‘æ’­æ”¾å™¨ ---
        let videoTexture = null;
        let videoElement = null;
        let videoPlane = null;
        
        function createVideoPlayer() {
            if (videoPlane) return;
            
            videoElement = document.createElement('video');
            videoElement.loop = true;
            videoElement.muted = false;
            
            videoTexture = new THREE.VideoTexture(videoElement);
            videoTexture.colorSpace = THREE.SRGBColorSpace;
            
            const videoMat = new THREE.MeshBasicMaterial({ 
                map: videoTexture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0
            });
            
            videoPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 20),
                videoMat
            );
            videoPlane.position.set(0, 0, 25);
            videoPlane.visible = false;
            scene.add(videoPlane);
        }
        
        function playVideo(file) {
            createVideoPlayer();
            
            const url = URL.createObjectURL(file);
            videoElement.src = url;
            videoElement.play().catch(e => console.log('è§†é¢‘æ’­æ”¾å¤±è´¥:', e));
            
            videoPlane.material.opacity = 0;
            videoPlane.visible = true;
            
            // æ·¡å…¥æ•ˆæœ
            let opacity = 0;
            const fadeIn = () => {
                opacity += 0.02;
                videoPlane.material.opacity = opacity;
                if (opacity < 1) {
                    requestAnimationFrame(fadeIn);
                }
            };
            fadeIn();
        }

        // --- 9. å·¨å‹è‰ºæœ¯å­— & ç…§ç‰‡ ---
        const textPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 15), 
            new THREE.MeshBasicMaterial({side:THREE.DoubleSide, transparent:true})
        );
        textPlane.renderOrder = 999; 
        
        function makeArtTextTex() {
            const c=document.createElement('canvas'); c.width=4096; c.height=1024;
            const x=c.getContext('2d');
            x.shadowColor="#00ffff"; x.shadowBlur=40;
            x.fillStyle="#fff"; 
            x.font="bold 400px 'Brush Script MT', cursive"; 
            x.textAlign="center"; x.textBaseline="middle";
            x.fillText("Merry Christmas", 2048, 512);
            return new THREE.CanvasTexture(c);
        }
        textPlane.material.map = makeArtTextTex();
        textPlane.visible = false;
        scene.add(textPlane);

        // --- 10. ç…§ç‰‡ç³»ç»Ÿ ---
        const photoGroup = new THREE.Group();
        const photoPlane = new THREE.Mesh(new THREE.PlaneGeometry(36, 27), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
        const photoBorder = new THREE.Mesh(new THREE.PlaneGeometry(37, 28), new THREE.MeshBasicMaterial({color:0xffd700}));
        photoBorder.position.z = -0.1;
        photoGroup.add(photoPlane); photoGroup.add(photoBorder);
        photoGroup.visible = false;
        photoGroup.renderOrder = 999; 
        scene.add(photoGroup);

        const galleryGroup = new THREE.Group();
        scene.add(galleryGroup);

        let mode = 'tree';
        let photoImages = [];
        let handRot = {x:0, y:0};
        let animState = { photo: 0, text: 0, galaxy: 0, video: 0 };
        let currentPhotoParams = { targetZ: 15, tiltX: 0, tiltY: 0 };
        let currentTreeType = 'classic';

        // --- 11. ç…§ç‰‡ä¿å­˜ä¸åŠ è½½ ---
        function savePhotosToStorage() {
            const photoData = photoImages.map(tex => {
                // å°†çº¹ç†è½¬æ¢ä¸ºbase64
                const canvas = document.createElement('canvas');
                canvas.width = tex.image.width;
                canvas.height = tex.image.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(tex.image, 0, 0);
                return {
                    data: canvas.toDataURL('image/jpeg', 0.8), // å‹ç¼©ä¸ºJPEG
                    width: tex.image.width,
                    height: tex.image.height
                };
            });
            
            DataManager.saveData({
                photos: photoData,
                settings: {
                    treeType: currentTreeType,
                    lastMode: mode
                },
                treeType: currentTreeType
            });
        }

        function loadPhotosFromStorage() {
            const savedData = DataManager.loadData();
            if (savedData && savedData.photos) {
                photoImages = savedData.photos.map(photo => {
                    const img = new Image();
                    img.src = photo.data;
                    const tex = new THREE.Texture(img);
                    img.onload = () => {
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                    };
                    return tex;
                });
                
                       function loadPhotosFromStorage() {
            const savedData = DataManager.loadData();
                    
                   if (savedData) {
                currentTreeType = savedData.treeType || 'classic';
            }

          const params = new URLSearchParams(window.location.search);
            const sharedType = params.get('tree'); 
            if (sharedType) {
                currentTreeType = sharedType;
                console.log('æ£€æµ‹åˆ°åˆ†äº«é“¾æ¥ï¼Œåº”ç”¨æ¨¡å¼:', sharedType);
            }
        
            updateTreeTypeButtons(); 
            createGalleryCloud();    
            
            if(savedData && savedData.photos) {
                console.log(`å·²åŠ è½½ ${photoImages.length} å¼ ä¿å­˜çš„ç…§ç‰‡`);
            }
        }
                updateTreeTypeButtons();
                createGalleryCloud();
                
                console.log(`å·²åŠ è½½ ${photoImages.length} å¼ ä¿å­˜çš„ç…§ç‰‡`);
            }
        }

        // --- 12. ç…§ç‰‡æ˜Ÿç³»ç”Ÿæˆ ---
        function createGalleryCloud() {
            while(galleryGroup.children.length > 0){ 
                galleryGroup.remove(galleryGroup.children[0]); 
            }

            if(photoImages.length === 0) return;

            const totalGalleryCount = Math.min(40, photoImages.length * 3);
            const geo = new THREE.PlaneGeometry(8, 6);
            const borderGeo = new THREE.PlaneGeometry(8.5, 6.5);
            const borderMat = new THREE.MeshBasicMaterial({color: 0xffd700});

            for(let i=0; i<totalGalleryCount; i++) {
                const imgTex = photoImages[i % photoImages.length];
                const mat = new THREE.MeshBasicMaterial({map: imgTex, side: THREE.DoubleSide});
                
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.05;
                mesh.add(border);

                const r = 25 + Math.random() * 35;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const tx = r * Math.sin(phi) * Math.cos(theta);
                const ty = r * Math.sin(phi) * Math.sin(theta);
                const tz = r * Math.cos(phi);

                mesh.userData = {
                    targetPos: new THREE.Vector3(tx, ty, tz),
                    startPos: new THREE.Vector3(0, 0, 0),
                    rotSpeed: (Math.random()-0.5) * 0.02
                };
                
                mesh.position.set(0,0,0);
                mesh.scale.set(0,0,0);
                
                galleryGroup.add(mesh);
            }
        }

        // --- 13. åœ£è¯æ ‘ç±»å‹åˆ‡æ¢ ---
        function updateTreeTypeButtons() {
            document.querySelectorAll('.tree-type-btn').forEach(btn => {
                btn.classList.remove('active');
                if(btn.dataset.type === currentTreeType) {
                    btn.classList.add('active');
                }
            });
        }

        function setTreeType(type) {
            currentTreeType = type;
            updateTreeTypeButtons();
            
            if (treeGenerators[type]) {
                treeGenerators[type](1.0);
            }
        }

        // åˆå§‹åŒ–æ ‘ç±»å‹æŒ‰é’®äº‹ä»¶
        document.querySelectorAll('.tree-type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setTreeType(btn.dataset.type);
            });
        });

        // --- 14. æ‰‹åŠ¿è¯†åˆ«å¢å¼º ---
        function detectEnhanced(lm) {
            const d = (i1, i2) => Math.hypot(lm[i1].x-lm[i2].x, lm[i1].y-lm[i2].y);
            const o = (t, p) => d(t, 0) > d(p, 0);
            const i=o(8,6), m=o(12,10), r=o(16,14), p=o(20,18);
            
            // åŸºç¡€æ‰‹åŠ¿
            if(!i&&!m&&!r&&!p) return 'FIST';
            if(i && !m && !r && !p) return 'POINTING';
            if(d(4,8)<0.05&&m&&r&&p) return 'OK';
            if(i&&m&&r&&p) return 'OPEN';
            
            // æ–°å¢æ‰‹åŠ¿ï¼šVå­—æ‰‹åŠ¿ï¼ˆé£ŸæŒ‡å’Œä¸­æŒ‡å¼ å¼€ï¼‰
            if(i && m && !r && !p) return 'V_SIGN';
            
            // æ–°å¢æ‰‹åŠ¿ï¼šæ‘‡æ»šæ‰‹åŠ¿ï¼ˆé£ŸæŒ‡å’Œå°æŒ‡å¼ å¼€ï¼‰
            if(i && !m && !r && p) return 'ROCK_SIGN';
            
            return 'UNKNOWN';
        }

        // --- 15. æ–‡ä»¶ä¸Šä¼ å¤„ç† ---
        document.getElementById('photo-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if(files.length){
                let loadCount = 0;
                const limit = Math.min(files.length, 30);
                
                for(let i=0; i<limit; i++){
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const img = new Image(); 
                        img.src = ev.target.result;
                        img.onload = () => {
                            const tex = new THREE.Texture(img);
                            tex.colorSpace = THREE.SRGBColorSpace;
                            tex.needsUpdate = true;
                            photoImages.push(tex);
                            loadCount++;
                            
                            if(loadCount === limit) {
                                createGalleryCloud();
                                savePhotosToStorage(); // è‡ªåŠ¨ä¿å­˜
                            }
                        }
                    };
                    reader.readAsDataURL(files[i]);
                }
            }
        });

        document.getElementById('video-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file && file.type.startsWith('video/')) {
                playVideo(file);
            }
        });

        document.getElementById('music-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if(files.length){
                for(let i=0; i<files.length; i++){
                    if(files[i].type.startsWith('audio/')) {
                        musicPlayer.addTrack(files[i]);
                    }
                }
            }
        });

        // --- 16. UIæ§åˆ¶å‡½æ•° ---
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`å…¨å±è¯·æ±‚å¤±è´¥: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        function toggleUI() {
            const ui = document.getElementById('ui-container');
            ui.classList.toggle('hidden');
        }

        function clearStorage() {
            if(confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰ä¿å­˜çš„ç…§ç‰‡å’Œè®¾ç½®å—ï¼Ÿ')) {
                DataManager.clearData();
            }
        }

        function exportSettings() {
            DataManager.exportSettings();
        }

        function toggleMusic() {
            musicPlayer.togglePlay();
               function toggleMusic() {
            musicPlayer.togglePlay();
        }

        // --- æ–°å¢ï¼šå¤åˆ¶åˆ†äº«é“¾æ¥åŠŸèƒ½ ---
        function copyShareLink() {
            // 1. è·å–å½“å‰çš„åŸºç¡€ç½‘å€
            const url = new URL(window.location.href.split('?')[0]);
            
            // 2. å°†å½“å‰çš„è®¾ç½®å†™å…¥ç½‘å€å‚æ•°
            // ä¿å­˜å½“å‰çš„æ ‘å½¢æ¨¡å¼ (ä¾‹å¦‚ sphere, spiral)
            url.searchParams.set('tree', currentTreeType);
            
            // (å¯é€‰) ä¿å­˜å½“å‰éŸ³é‡
            const volume = document.getElementById('volume-slider').value;
            url.searchParams.set('vol', volume);

            // 3. å¤åˆ¶åˆ°å‰ªè´´æ¿
            const finalLink = url.toString();
            
            navigator.clipboard.writeText(finalLink).then(() => {
                alert('âœ… é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼\n\n' + finalLink + '\n\næç¤ºï¼šæ­¤é“¾æ¥åŒ…å«å½“å‰çš„â€œè§†å›¾æ¨¡å¼â€é…ç½®ã€‚å‘é€ç»™æœ‹å‹æ—¶ï¼Œä»–ä»¬æ‰“å¼€é“¾æ¥ä¼šè‡ªåŠ¨åˆ‡æ¢åˆ°ä½ å½“å‰çš„ 3D å½¢çŠ¶ã€‚');
            }).catch(err => {
                console.error('å¤åˆ¶å¤±è´¥', err);
                prompt('æ— æ³•è‡ªåŠ¨å¤åˆ¶ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ä»¥ä¸‹é“¾æ¥ï¼š', finalLink);
            });
        } }

        function prevTrack() {
            musicPlayer.prevTrack();
        }

        function nextTrack() {
            musicPlayer.nextTrack();
        }

        // --- 17. åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            let tx = 0, ty = 0;
            if (mode !== 'photo') {
                tx = handRot.y * 0.5;
                ty = handRot.x * 0.5;
            }

            const rotSpeed = 0.08;
            meshCubes.rotation.x = THREE.MathUtils.lerp(meshCubes.rotation.x, tx, rotSpeed);
            meshCubes.rotation.y = THREE.MathUtils.lerp(meshCubes.rotation.y, ty, rotSpeed);
            meshSpheres.rotation.copy(meshCubes.rotation); 
            meshFrames.rotation.copy(meshCubes.rotation); 
            meshGifts.rotation.copy(meshCubes.rotation);

            // ç…§ç‰‡æ˜Ÿç³»æ—‹è½¬
            galleryGroup.rotation.y += 0.002;
            galleryGroup.rotation.x = meshCubes.rotation.x * 0.5;
            galleryGroup.rotation.y += meshCubes.rotation.y * 0.5;

            // æ ‘æ¨¡å¼
            if (mode === 'tree') {
                topStar.visible = true;
                topStar.position.set(0, 30 + Math.sin(time)*1.0, 0); 
                topStar.position.applyEuler(meshCubes.rotation);
                topStar.rotation.z = time * 0.5;
                topStar.lookAt(camera.position); 
                tubeMesh.visible = true;
                tubeMesh.rotation.copy(meshCubes.rotation);
                tubeMesh.rotation.y += time;
            } else {
                topStar.visible = false;
                tubeMesh.visible = false;
            }

            // å•å¼ ç‰¹å†™æ¨¡å¼
            if (mode === 'photo') {
                photoGroup.visible = true;
                animState.photo = THREE.MathUtils.lerp(animState.photo, 1, 0.15); 
                const s = animState.photo;
                const z = -20 * (1-s) + 12; 
                photoGroup.scale.set(s, s, s);
                photoGroup.position.set(0, 0, z); 
                photoGroup.rotation.z = (1-s) * 0.3;
            } else {
                photoGroup.visible = false;
                animState.photo = 0;
            }

            // æ–‡å­—æ¨¡å¼
            if (mode === 'text') {
                textPlane.visible = true;
                animState.text = THREE.MathUtils.lerp(animState.text, 1, 0.1);
                const s = 1 + Math.sin((1-animState.text)*Math.PI)*0.3; 
                textPlane.scale.set(s,s,1);
                textPlane.position.set(0, Math.sin(time*2)*0.5, 15); 
            } else {
                textPlane.visible = false;
                animState.text = 0;
            }

            // è§†é¢‘æ¨¡å¼
            if (mode === 'video' && videoPlane) {
                animState.video = THREE.MathUtils.lerp(animState.video, 1, 0.05);
                videoPlane.visible = true;
                videoPlane.scale.setScalar(animState.video);
                videoPlane.lookAt(camera.position);
                videoPlane.position.y = Math.sin(time) * 2;
            } else if (videoPlane) {
                videoPlane.visible = false;
                animState.video = 0;
            }

            // æ˜Ÿç³»æ¨¡å¼
            if (mode === 'nebula') {
                animState.galaxy = THREE.MathUtils.lerp(animState.galaxy, 1, 0.05);
                galleryGroup.children.forEach(mesh => {
                    mesh.position.lerp(mesh.userData.targetPos, 0.05);
                    mesh.scale.setScalar(animState.galaxy);
                    mesh.lookAt(camera.position);
                    mesh.position.y += Math.sin(time + mesh.id) * 0.02;
                });
            } else {
                animState.galaxy = THREE.MathUtils.lerp(animState.galaxy, 0, 0.1);
                galleryGroup.children.forEach(mesh => {
                    mesh.position.lerp(new THREE.Vector3(0,0,0), 0.1);
                    mesh.scale.setScalar(animState.galaxy);
                });
            }

            // ç²’å­æ›´æ–°
            let ic=0, is=0, ifr=0, ig=0;
            const particleLerp = (mode === 'photo') ? 0.9 : 0.08;

            for(let i=0; i<totalParticles; i++){
                const ix=i*3, iy=i*3+1, iz=i*3+2;
                currentPositions[ix] += (targetPositions[ix]-currentPositions[ix])*particleLerp;
                currentPositions[iy] += (targetPositions[iy]-currentPositions[iy])*particleLerp;
                currentPositions[iz] += (targetPositions[iz]-currentPositions[iz])*particleLerp;
                
                dummy.position.set(currentPositions[ix], currentPositions[iy], currentPositions[iz]);
                
                let s = 1.0;
                if (mode !== 'photo') {
                    if(i >= countCubes+countSpheres) { 
                        dummy.rotation.set(time+i, time*0.5+i, 0);
                        s = 1.0 + Math.sin(time*3+i)*0.15;
                    } else {
                        dummy.rotation.set(0,0,0);
                    }
                } else {
                    dummy.rotation.set(0,0,0);
                    s = 1.0;
                }
                
                dummy.scale.set(s,s,s);
                dummy.updateMatrix();

                if(i<countCubes) meshCubes.setMatrixAt(ic++, dummy.matrix);
                else if(i<countCubes+countSpheres) meshSpheres.setMatrixAt(is++, dummy.matrix);
                else if(i<countCubes+countSpheres+countFrames) meshFrames.setMatrixAt(ifr++, dummy.matrix);
                else meshGifts.setMatrixAt(ig++, dummy.matrix);
            }
            meshCubes.instanceMatrix.needsUpdate=true;
            meshSpheres.instanceMatrix.needsUpdate=true;
            meshFrames.instanceMatrix.needsUpdate=true;
            meshGifts.instanceMatrix.needsUpdate=true;

            // é›ªèŠ±æ›´æ–°
            const sp = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<snowCount; i++){
                sp[i*3+1] -= 0.35; 
                if(sp[i*3+1]<-100) sp[i*3+1]=100;
            }
            snowSystem.geometry.attributes.position.needsUpdate=true;

            renderer.render(scene, camera);
        }

        // --- 18. æ‰‹åŠ¿å¤„ç† ---
        let lastGesture = '';
        function handleGesture(gesture) {
            if(gesture === lastGesture) return;
            
            lastGesture = gesture; 
            document.getElementById('status-text').innerText = gesture;
            
            switch(gesture){
                case 'OPEN': 
                    mode='nebula'; 
                    // é‡æ–°è®¡ç®—ç²’å­ä½ç½®
                    for(let i=0; i<totalParticles; i++){
                        const r=80*Math.cbrt(Math.random()); 
                        const th=Math.random()*2*Math.PI; 
                        const ph=Math.acos(2*Math.random()-1);
                        targetPositions[i*3] = r*Math.sin(ph)*Math.cos(th);
                        targetPositions[i*3+1] = r*Math.sin(ph)*Math.sin(th);
                        targetPositions[i*3+2] = r*Math.cos(ph);
                    }
                    if(galleryGroup.children.length === 0 && photoImages.length > 0) createGalleryCloud();
                    break;
                    
                case 'FIST': 
                    mode='tree'; 
                    // å¾ªç¯åˆ‡æ¢åœ£è¯æ ‘ç±»å‹
                    const types = ['classic', 'spiral', 'crystal', 'fractal'];
                    const currentIndex = types.indexOf(currentTreeType);
                    const nextType = types[(currentIndex + 1) % types.length];
                    setTreeType(nextType);
                    break;
                    
                case 'POINTING': 
                    mode='photo'; 
                    if(photoImages.length) {
                        photoPlane.material.map = photoImages[Math.floor(Math.random()*photoImages.length)];
                        photoPlane.material.needsUpdate = true;
                    }
                    break;
                    
                case 'OK': 
                    mode='text'; 
                    break;
                    
                case 'V_SIGN': // Vå­—æ‰‹åŠ¿ - æ’­æ”¾è§†é¢‘
                    mode='video';
                    if(videoElement && videoElement.paused) {
                        videoElement.play().catch(e => console.log('æ‰‹åŠ¿æ’­æ”¾è§†é¢‘å¤±è´¥:', e));
                    }
                    break;
                    
                case 'ROCK_SIGN': // æ‘‡æ»šæ‰‹åŠ¿ - éŸ³ä¹æ§åˆ¶
                    musicPlayer.togglePlay();
                    break;
            }
        }

        // --- 19. åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ« ---
        const videoElementHand = document.getElementById('input_video');
        const statusText = document.getElementById('status-text');

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            statusText.style.display = 'block';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const cx = (lm[0].x+lm[9].x)/2; const cy = (lm[0].y+lm[9].y)/2;
                handRot.x = (cx-0.5)*3; handRot.y = (cy-0.5)*3;
                handleGesture(detectEnhanced(lm));
            }
        }

        // --- 20. å¯åŠ¨ ---
        function init() {
            // åˆå§‹åŒ–åœ£è¯æ ‘
            setTreeType('classic');
            
            // åŠ è½½ä¿å­˜çš„ç…§ç‰‡
            loadPhotosFromStorage();
            
            // å¯åŠ¨åŠ¨ç”»
            animate();
            
            // å¯åŠ¨æ‰‹åŠ¿è¯†åˆ«
            const hands = new Hands({locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
            hands.onResults(onResults);
            const cam = new Camera(videoElementHand, {onFrame: async()=>{await hands.send({image:videoElementHand})}, width:320, height:240});
            cam.start();
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', init);
    // --- æ–°å¢åŠŸèƒ½ï¼šåˆ†äº«åˆ°å¾®ä¿¡ & æ‰‹æœºè§¦æ‘¸æ§åˆ¶ ---

    function shareToWeChat() {
        // 1. å®‰å…¨æ£€æŸ¥ï¼šå¿…é¡»å‘å¸ƒåˆ°ç½‘ç»œæ‰èƒ½åœ¨æ‰‹æœºæ‰“å¼€
        if (window.location.protocol === 'file:') {
            alert('âŒ æ— æ³•åˆ†äº«æœ¬åœ°æ–‡ä»¶ï¼\n\nä½ ç°åœ¨æ˜¯ç›´æ¥æ‰“å¼€çš„æ–‡ä»¶ (file://)ã€‚\nè¯·å…ˆå°†è¿™ä¸ªç½‘é¡µä¸Šä¼ åˆ°æœåŠ¡å™¨ (å¦‚ GitHub Pages)ï¼Œç”Ÿæˆ http/https é“¾æ¥åæ‰èƒ½å‘ç»™æœ‹å‹ã€‚');
            return;
        }

        // 2. ç”Ÿæˆé“¾æ¥
        const url = new URL(window.location.href.split('?')[0]);
        url.searchParams.set('tree', currentTreeType || 'classic'); // ä¿å­˜å½“å‰æ ‘å½¢
        const vol = document.getElementById('volume-slider') ? document.getElementById('volume-slider').value : 50;
        url.searchParams.set('vol', vol); // ä¿å­˜éŸ³é‡

        const finalLink = url.toString();

        // 3. å¤åˆ¶å¹¶è·³è½¬
        navigator.clipboard.writeText(finalLink).then(() => {
            // å¤åˆ¶æˆåŠŸï¼Œè¯¢é—®æ˜¯å¦æ‰“å¼€å¾®ä¿¡
            if(confirm('âœ… é“¾æ¥å·²å¤åˆ¶ï¼\n\nç‚¹å‡»â€œç¡®å®šâ€å°†å°è¯•æ‰“å¼€å¾®ä¿¡ã€‚\nè¯·åœ¨å¾®ä¿¡èŠå¤©æ¡†ä¸­â€œç²˜è´´â€å³å¯å‘é€ã€‚')) {
                window.location.href = "weixin://";
            }
        }).catch(err => {
            console.error(err);
            prompt("æ— æ³•è‡ªåŠ¨å¤åˆ¶ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶é“¾æ¥ï¼š", finalLink);
        });
    }

    // --- æ‰‹æœºè§¦æ‘¸æ§åˆ¶æ”¯æŒ (æ— éœ€æ‘„åƒå¤´å³å¯æ—‹è½¬) ---
    // è®©æœ‹å‹åœ¨æ‰‹æœºä¸Šæ‰“å¼€æ—¶ï¼Œå¯ä»¥ç”¨æ‰‹æŒ‡æ»‘åŠ¨å±å¹•æ¥æ—‹è½¬æ ‘
    document.addEventListener('DOMContentLoaded', () => {
        let touchStartX = 0;
        let touchStartY = 0;

        const touchContainer = document.body; // å…¨å±å“åº”

        touchContainer.addEventListener('touchstart', (e) => {
            if(e.touches.length > 0) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        }, {passive: false});

        touchContainer.addEventListener('touchmove', (e) => {
            // å¦‚æœæ˜¯ç…§ç‰‡å±•ç¤ºæ¨¡å¼ï¼Œæˆ–è€…æ˜¯å¤šæŒ‡æ“ä½œï¼Œåˆ™ä¸å¤„ç†
            if (typeof mode !== 'undefined' && mode === 'photo') return;
            if (e.touches.length === 0) return;

            // é˜»æ­¢é»˜è®¤çš„ç½‘é¡µæ»šåŠ¨
            e.preventDefault();

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            // è®¡ç®—æ»‘åŠ¨è·ç¦»
            const deltaX = (touchX - touchStartX) * 0.005;
            const deltaY = (touchY - touchStartY) * 0.005;

            // ç›´æ¥æ§åˆ¶ 3D å¯¹è±¡æ—‹è½¬ (å‡è®¾å¯¹è±¡åä¸º meshCubes)
            if (typeof meshCubes !== 'undefined') {
                meshCubes.rotation.y += deltaX;
                meshCubes.rotation.x += deltaY;
            }

            // æ›´æ–°èµ·å§‹ç‚¹
            touchStartX = touchX;
            touchStartY = touchY;
        }, {passive: false});
    });
    </script>
</body>
</html>